{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Netatmo GeoPy Pythonic package to access Netatmo CWS data. import netatmo_geopy as nat lon_sw, lat_sw, lon_ne, lat_ne = 6.5175, 46.5012, 6.7870, 46.6058 cws_recorder = nat.CWSRecorder(lon_sw, lat_sw, lon_ne, lat_ne) gdf = cws_recorder.get_snapshot_gdf() gdf.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2022-02-12T19:13 geometry station_id 02:00:00:01:5e:e0 6.6 POINT (6.82799 46.47089) 02:00:00:22:c0:c0 4.9 POINT (6.82904 46.47005) 02:00:00:2f:0b:16 3.5 POINT (6.82516 46.47294) 02:00:00:59:00:2a 3.8 POINT (6.84547 46.46779) 02:00:00:52:ed:5a 3.8 POINT (6.87359 46.47067) nat.plot_snapshot(gdf) See the user guide for a more thorough overview of netatmo-geopy. Acknowledgements This package was created with Cookiecutter and the zillionare/cookiecutter-pypackage project template.","title":"Home"},{"location":"#netatmo-geopy","text":"Pythonic package to access Netatmo CWS data. import netatmo_geopy as nat lon_sw, lat_sw, lon_ne, lat_ne = 6.5175, 46.5012, 6.7870, 46.6058 cws_recorder = nat.CWSRecorder(lon_sw, lat_sw, lon_ne, lat_ne) gdf = cws_recorder.get_snapshot_gdf() gdf.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2022-02-12T19:13 geometry station_id 02:00:00:01:5e:e0 6.6 POINT (6.82799 46.47089) 02:00:00:22:c0:c0 4.9 POINT (6.82904 46.47005) 02:00:00:2f:0b:16 3.5 POINT (6.82516 46.47294) 02:00:00:59:00:2a 3.8 POINT (6.84547 46.46779) 02:00:00:52:ed:5a 3.8 POINT (6.87359 46.47067) nat.plot_snapshot(gdf) See the user guide for a more thorough overview of netatmo-geopy.","title":"Netatmo GeoPy"},{"location":"#acknowledgements","text":"This package was created with Cookiecutter and the zillionare/cookiecutter-pypackage project template.","title":"Acknowledgements"},{"location":"api/","text":"Top-level package for Netatmo GeoPy. auth Authentication. NetatmoConnect NetatmoConnect. session property readonly Session. token property readonly Token. token_updater ( self , token ) Token updater. Source code in netatmo_geopy/auth.py def token_updater ( self , token ): \"\"\"Token updater.\"\"\" self . _token = token RefreshOAuth2Session RefreshOAuth2Session. request ( self , * args , ** kwargs ) Intercept all requests and add the OAuth 2 token if present. Source code in netatmo_geopy/auth.py def request ( self , * args , ** kwargs ): try : return super () . request ( * args , ** kwargs ) except oauth2 . TokenExpiredError : self . token = self . fetch_token ( ** self . auto_refresh_kwargs ) self . token_updater ( self . token ) return super () . request ( * args , ** kwargs ) cli Console script for netatmo_geopy. help () Show CLI help. Source code in netatmo_geopy/cli.py def help (): \"\"\"Show CLI help.\"\"\" print ( \"netatmo_geopy\" ) print ( \"=\" * len ( \"netatmo_geopy\" )) print ( \"Pythonic package to access Netatmo CWS data\" ) main () Main. Source code in netatmo_geopy/cli.py def main (): \"\"\"Main.\"\"\" fire . Fire ({ \"help\" : help }) core Main module. CWSDataset CWSDataset. temperature_gdf property readonly Time series of temperature measurements at the station locations. __init__ ( self , * , snapshot_filepaths = None , snapshot_data_dir = None , snapshot_file_ext = None , datetime_format = None ) special Initialize a CWS dataset from recorded snapshot files. Parameters snapshot_filepaths : list-like of str, path or file-like objects, optional List of paths to the input snapshot recording files, passed to geopandas.read_file . snapshot_data_dir : str or pathlib.Path object Path to the directory where the snapshot recording files are located. Ignored if snapshot_filepaths is provided. snapshot_file_ext : str, optional File extension of the snapshot recording, used to obtain the list of input files in snapshot_data_dir . If None, the default value from settings.DEFAULT_SNAPSHOT_FILE_EXT is used. Ignored if snapshot_filepaths is provided. datetime_format : str, optional Datetime format string. Used to name the geo-data frame columns and the snapshot file dumps. If None, the default value from settings.DEFAULT_DATETIME_FORMAT is used. Source code in netatmo_geopy/core.py def __init__ ( self , * , snapshot_filepaths = None , snapshot_data_dir = None , snapshot_file_ext = None , datetime_format = None , ): \"\"\" Initialize a CWS dataset from recorded snapshot files. Parameters ---------- snapshot_filepaths : list-like of str, path or file-like objects, optional List of paths to the input snapshot recording files, passed to `geopandas.read_file`. snapshot_data_dir : str or pathlib.Path object Path to the directory where the snapshot recording files are located. Ignored if `snapshot_filepaths` is provided. snapshot_file_ext : str, optional File extension of the snapshot recording, used to obtain the list of input files in `snapshot_data_dir`. If None, the default value from `settings.DEFAULT_SNAPSHOT_FILE_EXT` is used. Ignored if `snapshot_filepaths` is provided. datetime_format : str, optional Datetime format string. Used to name the geo-data frame columns and the snapshot file dumps. If None, the default value from `settings.DEFAULT_DATETIME_FORMAT` is used. \"\"\" super ( CWSDataset , self ) . __init__ () if snapshot_filepaths is None : if snapshot_file_ext is None : snapshot_file_ext = settings . DEFAULT_SNAPSHOT_FILE_EXT snapshot_filepaths = glob . glob ( path . join ( snapshot_data_dir , f \"*. { snapshot_file_ext } \" ) ) self . snapshot_filepaths = snapshot_filepaths if datetime_format is None : datetime_format = settings . DEFAULT_DATETIME_FORMAT self . datetime_format = datetime_format CWSRecorder CWSRecorder. __init__ ( self , lon_sw , lat_sw , lon_ne , lat_ne , * , dst_dir = None , client_id = None , client_secret = None , username = None , password = None , time_unit = None , interval = None , at = None , until = None , datetime_format = None , snapshot_file_ext = None , save_responses = None , save_responses_dir = None ) special Initialize a CWS recorder for a given region. Parameters lon_sw, lat_sw, lon_ne, lat_ne : numeric Latitude/longitude coordinates of the bounds of the region of interest dst_dir : str or pathlib.Path object, optional Path to the directory where the recorded snapshots are to be dumped. Only used when the dump_snapshot_gdf method is called, ignored otherwise. If None, the default value from settings.DEAFULT_DST_DIR . client_id, client_secret, username, password : str, optional Authentication credentials for Netatmo. If None, the respective values set in the \"NETATMO_CLIENT_ID\", \"NETATMO_CLIENT_SECRET\", \"NETATMO_USERNAME\" and \"NETATMO_PASSWORD\" environment variables are used. time_unit : str {\"second\", \"seconds\", \"minute\", \"minutes\", \"hour\", \"hours\", \"day\", \"days\", \"week\", \"weeks\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"}, optional Time unit. If None, no snaphots are taken periodically - snapshots are only taken by manually calling get_snapshot_gdf or dump_snapshot_gdf . interval : int, optional Quantity of the time unit set in time_unit , altogether defining the interval between snapshots. If None, the default value from the schedule library, i.e., 1, is used. Ignored if time_unit is None. at : str, optional Time string defining the particular time when snapshots are taken. See also https://schedule.readthedocs.io/en/stable/reference.html#schedule.Job.at. Ignored if time_unit is None. The following formats are accepted: * for daily jobs -> HH:MM:SS or HH:MM * for hourly jobs -> MM:SS or :MM * for minute jobs -> :SS. until : datetime.datetime, datetime.timedelta, datetime.time or str, optional Latest time (in the future) when a snapshot will be taken. If None, the periodic snapshots are taken indefinetly. Ignored if time_unit is None. The following formats are accepted: * datetime.datetime * datetime.timedelta * datetime.time * string in one of the following formats: \"%Y-%m-%d %H:%M:%S\", \"%Y-%m-%d %H:%M\", \"%Y-%m-%d\", \"%H:%M:%S\", \"%H:%M\" as defined by `datetime.strptime` behaviour. datetime_format : str, optional Datetime format string. Used to name the geo-data frame columns and the snapshot file dumps. If None, the default value from settings.DEFAULT_DATETIME_FORMAT is used. snapshot_file_ext : str, optional File extension used when dumping recorded snapshot files, which must match an OGR vector format driver (see fiona.supported_drivers ). If None, the default value from settings.DEFAULT_SNAPSHOT_FILE_EXT is used. save_responses : bool, optional Whether the JSON responses from the Netatmo public data API calls are stored. If None, the default value from settings.DEFAULT_SAVE_RESPONSES is used. save_responses_dir : str or pathlib.Path object, optional. Path to the directory where the JSON responses are to be stored. If None, the default value from settings.DEFAULT_SAVE_RESPONSES_DIR is used. Ignored if save_responses is False. Source code in netatmo_geopy/core.py def __init__ ( self , lon_sw , lat_sw , lon_ne , lat_ne , * , dst_dir = None , client_id = None , client_secret = None , username = None , password = None , time_unit = None , interval = None , at = None , until = None , datetime_format = None , snapshot_file_ext = None , save_responses = None , save_responses_dir = None , ): \"\"\" Initialize a CWS recorder for a given region. Parameters ---------- lon_sw, lat_sw, lon_ne, lat_ne : numeric Latitude/longitude coordinates of the bounds of the region of interest dst_dir : str or pathlib.Path object, optional Path to the directory where the recorded snapshots are to be dumped. Only used when the `dump_snapshot_gdf` method is called, ignored otherwise. If None, the default value from `settings.DEAFULT_DST_DIR`. client_id, client_secret, username, password : str, optional Authentication credentials for Netatmo. If None, the respective values set in the \"NETATMO_CLIENT_ID\", \"NETATMO_CLIENT_SECRET\", \"NETATMO_USERNAME\" and \"NETATMO_PASSWORD\" environment variables are used. time_unit : str {\"second\", \"seconds\", \"minute\", \"minutes\", \"hour\", \"hours\", \\ \"day\", \"days\", \"week\", \"weeks\", \"monday\", \"tuesday\", \"wednesday\", \\ \"thursday\", \"friday\", \"saturday\", \"sunday\"}, optional Time unit. If None, no snaphots are taken periodically - snapshots are only taken by manually calling `get_snapshot_gdf` or `dump_snapshot_gdf`. interval : int, optional Quantity of the time unit set in `time_unit`, altogether defining the interval between snapshots. If None, the default value from the `schedule` library, i.e., 1, is used. Ignored if `time_unit` is None. at : str, optional Time string defining the particular time when snapshots are taken. See also https://schedule.readthedocs.io/en/stable/reference.html#schedule.Job.at. Ignored if `time_unit` is None. The following formats are accepted: * for daily jobs -> HH:MM:SS or HH:MM * for hourly jobs -> MM:SS or :MM * for minute jobs -> :SS. until : datetime.datetime, datetime.timedelta, datetime.time or str, optional Latest time (in the future) when a snapshot will be taken. If None, the periodic snapshots are taken indefinetly. Ignored if `time_unit` is None. The following formats are accepted: * datetime.datetime * datetime.timedelta * datetime.time * string in one of the following formats: \"%Y-%m-%d %H:%M:%S\", \"%Y-%m-%d %H:%M\", \"%Y-%m-%d\", \"%H:%M:%S\", \"%H:%M\" as defined by `datetime.strptime` behaviour. datetime_format : str, optional Datetime format string. Used to name the geo-data frame columns and the snapshot file dumps. If None, the default value from `settings.DEFAULT_DATETIME_FORMAT` is used. snapshot_file_ext : str, optional File extension used when dumping recorded snapshot files, which must match an OGR vector format driver (see `fiona.supported_drivers`). If None, the default value from `settings.DEFAULT_SNAPSHOT_FILE_EXT` is used. save_responses : bool, optional Whether the JSON responses from the Netatmo public data API calls are stored. If None, the default value from `settings.DEFAULT_SAVE_RESPONSES`is used. save_responses_dir : str or pathlib.Path object, optional. Path to the directory where the JSON responses are to be stored. If None, the default value from `settings.DEFAULT_SAVE_RESPONSES_DIR`is used. Ignored if `save_responses` is False. \"\"\" super ( CWSRecorder , self ) . __init__ () self . lon_sw = lon_sw self . lat_sw = lat_sw self . lon_ne = lon_ne self . lat_ne = lat_ne self . dst_dir = dst_dir # auth self . _client_id = client_id self . _client_secret = client_secret self . _username = username self . _password = password # IO if datetime_format is None : datetime_format = settings . DEFAULT_DATETIME_FORMAT self . datetime_format = datetime_format if snapshot_file_ext is None : snapshot_file_ext = settings . DEFAULT_SNAPSHOT_FILE_EXT self . snapshot_file_ext = snapshot_file_ext if save_responses is None : save_responses = settings . DEFAULT_SAVE_RESPONSES self . save_responses = save_responses if save_responses_dir is None : save_responses_dir = settings . DEFAULT_SAVE_RESPONSES_DIR self . save_responses_dir = save_responses_dir # schedule if time_unit : if interval : caller = schedule . every ( interval ) else : caller = schedule . every () caller = getattr ( caller , time_unit ) if at : caller = caller . at ( at ) if until : caller = caller . until ( until ) caller . do ( self . dump_snapshot_gdf ) while schedule . get_jobs (): schedule . run_pending () time . sleep ( 1 ) dump_snapshot_gdf ( self ) Get current CWS temperature snapshot and dump it to a file. Source code in netatmo_geopy/core.py def dump_snapshot_gdf ( self ): \"\"\"Get current CWS temperature snapshot and dump it to a file.\"\"\" snapshot_gdf = self . get_snapshot_gdf () dst_filepath = path . join ( self . dst_dir , f \" { _get_basename ( snapshot_gdf ) } . { self . snapshot_file_ext } \" ) snapshot_gdf . to_file ( dst_filepath ) utils . log ( f \"Dumped snapshot geo-data frame to file ' { dst_filepath } '\" ) get_snapshot_gdf ( self ) Get current CWS temperature snapshot. Source code in netatmo_geopy/core.py def get_snapshot_gdf ( self ): \"\"\"Get current CWS temperature snapshot.\"\"\" response_json = _get_public_data ( self . lon_sw , self . lat_sw , self . lon_ne , self . lat_ne , client_id = self . _client_id , client_secret = self . _client_secret , username = self . _username , password = self . _password , ) snapshot_gdf = _gdf_from_response_json ( response_json , self . datetime_format ) if self . save_responses : dst_response_filepath = path . join ( self . save_responses_dir , f \" { _get_basename ( snapshot_gdf ) } .json\" ) with open ( dst_response_filepath , \"w\" ) as dst : json . dump ( response_json , dst ) utils . log ( f \"Dumped response to file ' { dst_response_filepath } '\" ) return snapshot_gdf plot_snapshot ( snapshot_gdf , * , snapshot_column = None , ax = None , cmap = None , legend = None , legend_position = None , legend_size = None , legend_pad = None , title = None , add_basemap = None , attribution = None , subplot_kws = None , plot_kws = None , set_title_kws = None , add_basemap_kws = None , append_axes_kws = None ) Plot a snapshot of station measurements. Parameters snapshot_gdf : geopandas.GeoDataFrame Geo-data frame of CWS temperature measurements. snapshot_column : str, optional Column of CWS temperature measurements to plot. If None, the first column (other than geometry ) is used. ax : matplotlib.axes.Axes instancd, optional Plot in given axis. If None creates a new figure. cmap : str or matplotlib.colors.Colormap instance, optional Colormap of the plot. If None, the default value from settings.DEFAULT_PLOT_CMAP is used. legend : bool, optional Whether a legend should be added to the plot. If None, the default value from settings.DEFAULT_PLOT_LEGEND is used. legend_position : str {\"left\", \"right\", \"bottom\", \"top\"}, optional Position of the legend axes, passed to mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes . If None, the default value from settings.DEFAULT_PLOT_LEGEND_POSITION is used. legend_size : numeric or str, optional Size of the legend axes, passed to mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes . If None, the default value from settings.DEFAULT_PLOT_LEGEND_SIZE is used. legend_pad : numeric or str, optional Padding between the plot and legend axes, passed to mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes . If None, the default value from settings.DEFAULT_PLOT_LEGEND_PAD is used. title : bool or str, optional Whether a title should be added to the plot. If True, the timestamp of the snapshot (geo-data frame column) is used. It is also possible to pass a string so that it is used as title label (instead of the timestamp). If None, the default value from settings.DEFAULT_PLOT_TITLE is used. add_basemap : bool, optional Whether a basemap should be added to the plot using contextily.add_basemap . If None, the default value from settings.DEFAULT_PLOT_ADD_BASEMAP is used. attribution : str or bool, optional Attribution text for the basemap source, added to the bottom of the plot, passed to contextily.add_basemap . If False, no attribution is added. If None, the default value from settings.DEFAULT_PLOT_ATTRIBUTION is used. subplot_kws, plot_kws, set_title_kws, add_basemap_kws, append_axes_kws : dict, optional Keyword arguments passed to matplotlib.pyplot.subplots , geopandas.GeoDataFrame.plot , matplotlib.axes.Axes.set_title , contextily.add_basemap and mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes respectively. Returns ax : matplotlib.axes.Axes Axes with the plot drawn onto it. Source code in netatmo_geopy/core.py def plot_snapshot ( # noqa: C901 snapshot_gdf , * , snapshot_column = None , ax = None , cmap = None , legend = None , legend_position = None , legend_size = None , legend_pad = None , title = None , add_basemap = None , attribution = None , subplot_kws = None , plot_kws = None , set_title_kws = None , add_basemap_kws = None , append_axes_kws = None , ): \"\"\" Plot a snapshot of station measurements. Parameters ---------- snapshot_gdf : geopandas.GeoDataFrame Geo-data frame of CWS temperature measurements. snapshot_column : str, optional Column of CWS temperature measurements to plot. If None, the first column (other than `geometry`) is used. ax : `matplotlib.axes.Axes` instancd, optional Plot in given axis. If None creates a new figure. cmap : str or `matplotlib.colors.Colormap` instance, optional Colormap of the plot. If None, the default value from `settings.DEFAULT_PLOT_CMAP` is used. legend : bool, optional Whether a legend should be added to the plot. If None, the default value from `settings.DEFAULT_PLOT_LEGEND` is used. legend_position : str {\"left\", \"right\", \"bottom\", \"top\"}, optional Position of the legend axes, passed to `mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes`. If None, the default value from `settings.DEFAULT_PLOT_LEGEND_POSITION` is used. legend_size : numeric or str, optional Size of the legend axes, passed to `mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes`. If None, the default value from `settings.DEFAULT_PLOT_LEGEND_SIZE` is used. legend_pad : numeric or str, optional Padding between the plot and legend axes, passed to `mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes`. If None, the default value from `settings.DEFAULT_PLOT_LEGEND_PAD` is used. title : bool or str, optional Whether a title should be added to the plot. If True, the timestamp of the snapshot (geo-data frame column) is used. It is also possible to pass a string so that it is used as title label (instead of the timestamp). If None, the default value from `settings.DEFAULT_PLOT_TITLE` is used. add_basemap : bool, optional Whether a basemap should be added to the plot using `contextily.add_basemap`. If None, the default value from `settings.DEFAULT_PLOT_ADD_BASEMAP` is used. attribution : str or bool, optional Attribution text for the basemap source, added to the bottom of the plot, passed to `contextily.add_basemap`. If False, no attribution is added. If None, the default value from `settings.DEFAULT_PLOT_ATTRIBUTION` is used. subplot_kws, plot_kws, set_title_kws, add_basemap_kws, append_axes_kws : dict, \\ optional Keyword arguments passed to `matplotlib.pyplot.subplots`, `geopandas.GeoDataFrame.plot`, `matplotlib.axes.Axes.set_title`, `contextily.add_basemap` and `mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes` respectively. Returns ------- ax : `matplotlib.axes.Axes` Axes with the plot drawn onto it. \"\"\" # if no column is provided, we plot the \"first\" column other than \"geometry\" if snapshot_column is None : snapshot_column = snapshot_gdf . columns . drop ( \"geometry\" )[ 0 ] # subplots arguments if ax is None : if subplot_kws is None : subplot_kws = {} fig , ax = plt . subplots ( ** subplot_kws ) # plot arguments if plot_kws is None : _plot_kws = {} else : _plot_kws = plot_kws . copy () # _plot_kws = {key: plot_kws[key] for key in plot_kws} if cmap is None : cmap = _plot_kws . pop ( \"cmap\" , settings . DEFAULT_PLOT_CMAP ) if legend is None : legend = _plot_kws . pop ( \"legend\" , settings . DEFAULT_PLOT_LEGEND ) # plot if legend : divider = make_axes_locatable ( ax ) if legend_position is None : legend_position = settings . DEFAULT_PLOT_LEGEND_POSITION if legend_size is None : legend_size = settings . DEFAULT_PLOT_LEGEND_SIZE if append_axes_kws is None : _append_axes_kws = {} else : _append_axes_kws = append_axes_kws . copy () if legend_pad is None : legend_pad = _append_axes_kws . pop ( \"pad\" , settings . DEFAULT_PLOT_LEGEND_PAD ) _plot_kws [ \"cax\" ] = divider . append_axes ( legend_position , legend_size , pad = legend_pad , ** _append_axes_kws ) snapshot_gdf . plot ( column = snapshot_column , cmap = cmap , ax = ax , legend = legend , ** _plot_kws ) if title is None : title = settings . DEFAULT_PLOT_TITLE if title : if title is True : title_label = snapshot_column elif isinstance ( title , str ): title_label = title if set_title_kws is None : set_title_kws = {} ax . set_title ( title_label , ** set_title_kws ) # basemap if add_basemap is None : add_basemap = settings . DEFAULT_PLOT_ADD_BASEMAP if add_basemap : # raise ImportError( # \"The contextily package is required for adding basemaps. \" # \"You can install it using 'conda install -c conda-forge contextily' or \" # \"'pip install contextily'.\" # ) # add_basemap arguments if add_basemap_kws is None : _add_basemap_kws = {} else : _add_basemap_kws = add_basemap_kws . copy () # _add_basemap_kws = {key: add_basemap_kws[key] for key in add_basemap_kws} if attribution is None : attribution = _add_basemap_kws . pop ( \"attribution\" , settings . DEFAULT_PLOT_ATTRIBUTION ) # add basemap cx . add_basemap ( ax = ax , crs = snapshot_gdf . crs , attribution = attribution , ** _add_basemap_kws , ) return ax settings Settings. utils Utils (mostly from osmnx.utils ). log ( message , level = None , name = None , filename = None ) Write a message to the logger. This logs to file and/or prints to the console (terminal), depending on the current configuration of settings.LOG_FILE and settings.LOG_CONSOLE . Parameters message : str The message to log. level : int One of Python's logger.level constants. name : str Name of the logger. filename : str Name of the log file, without file extension. Source code in netatmo_geopy/utils.py def log ( message , level = None , name = None , filename = None ): \"\"\" Write a message to the logger. This logs to file and/or prints to the console (terminal), depending on the current configuration of `settings.LOG_FILE` and `settings.LOG_CONSOLE`. Parameters ---------- message : str The message to log. level : int One of Python's logger.level constants. name : str Name of the logger. filename : str Name of the log file, without file extension. \"\"\" if level is None : level = settings . LOG_LEVEL if name is None : name = settings . LOG_NAME if filename is None : filename = settings . LOG_FILENAME # if logging to file is turned on if settings . LOG_FILE : # get the current logger (or create a new one, if none), then log # message at requested level logger = _get_logger ( level = level , name = name , filename = filename ) if level == lg . DEBUG : logger . debug ( message ) elif level == lg . INFO : logger . info ( message ) elif level == lg . WARNING : logger . warning ( message ) elif level == lg . ERROR : logger . error ( message ) # if logging to console (terminal window) is turned on if settings . LOG_CONSOLE : # prepend timestamp message = f \" { ts () } { message } \" # convert to ascii so it doesn't break windows terminals message = ( unicodedata . normalize ( \"NFKD\" , str ( message )) . encode ( \"ascii\" , errors = \"replace\" ) . decode () ) # print explicitly to terminal in case jupyter notebook is the stdout if getattr ( sys . stdout , \"_original_stdstream_copy\" , None ) is not None : # redirect captured pipe back to original os . dup2 ( sys . stdout . _original_stdstream_copy , sys . __stdout__ . fileno ()) sys . stdout . _original_stdstream_copy = None with redirect_stdout ( sys . __stdout__ ): print ( message , file = sys . __stdout__ , flush = True ) ts ( style = 'datetime' , template = None ) Get current timestamp as str. Parameters style : str {\"datetime\", \"date\", \"time\"} Format the timestamp with this built-in template. template : str If not None, format the timestamp with this template instead of one of the built-in styles. Returns ts : str The string timestamp. Source code in netatmo_geopy/utils.py def ts ( style = \"datetime\" , template = None ): \"\"\" Get current timestamp as str. Parameters ---------- style : str {\"datetime\", \"date\", \"time\"} Format the timestamp with this built-in template. template : str If not None, format the timestamp with this template instead of one of the built-in styles. Returns ------- ts : str The string timestamp. \"\"\" if template is None : if style == \"datetime\" : template = \"{:%Y-%m- %d %H:%M:%S}\" elif style == \"date\" : template = \"{:%Y-%m- %d }\" elif style == \"time\" : template = \"{:%H:%M:%S}\" else : # pragma: no cover raise ValueError ( f 'unrecognized timestamp style \" { style } \"' ) ts = template . format ( dt . datetime . now ()) return ts","title":"API"},{"location":"api/#netatmo_geopy","text":"Top-level package for Netatmo GeoPy.","title":"netatmo_geopy"},{"location":"api/#netatmo_geopy.auth","text":"Authentication.","title":"auth"},{"location":"api/#netatmo_geopy.auth.NetatmoConnect","text":"NetatmoConnect.","title":"NetatmoConnect"},{"location":"api/#netatmo_geopy.auth.NetatmoConnect.session","text":"Session.","title":"session"},{"location":"api/#netatmo_geopy.auth.NetatmoConnect.token","text":"Token.","title":"token"},{"location":"api/#netatmo_geopy.auth.NetatmoConnect.token_updater","text":"Token updater. Source code in netatmo_geopy/auth.py def token_updater ( self , token ): \"\"\"Token updater.\"\"\" self . _token = token","title":"token_updater()"},{"location":"api/#netatmo_geopy.auth.RefreshOAuth2Session","text":"RefreshOAuth2Session.","title":"RefreshOAuth2Session"},{"location":"api/#netatmo_geopy.auth.RefreshOAuth2Session.request","text":"Intercept all requests and add the OAuth 2 token if present. Source code in netatmo_geopy/auth.py def request ( self , * args , ** kwargs ): try : return super () . request ( * args , ** kwargs ) except oauth2 . TokenExpiredError : self . token = self . fetch_token ( ** self . auto_refresh_kwargs ) self . token_updater ( self . token ) return super () . request ( * args , ** kwargs )","title":"request()"},{"location":"api/#netatmo_geopy.cli","text":"Console script for netatmo_geopy.","title":"cli"},{"location":"api/#netatmo_geopy.cli.help","text":"Show CLI help. Source code in netatmo_geopy/cli.py def help (): \"\"\"Show CLI help.\"\"\" print ( \"netatmo_geopy\" ) print ( \"=\" * len ( \"netatmo_geopy\" )) print ( \"Pythonic package to access Netatmo CWS data\" )","title":"help()"},{"location":"api/#netatmo_geopy.cli.main","text":"Main. Source code in netatmo_geopy/cli.py def main (): \"\"\"Main.\"\"\" fire . Fire ({ \"help\" : help })","title":"main()"},{"location":"api/#netatmo_geopy.core","text":"Main module.","title":"core"},{"location":"api/#netatmo_geopy.core.CWSDataset","text":"CWSDataset.","title":"CWSDataset"},{"location":"api/#netatmo_geopy.core.CWSDataset.temperature_gdf","text":"Time series of temperature measurements at the station locations.","title":"temperature_gdf"},{"location":"api/#netatmo_geopy.core.CWSDataset.__init__","text":"Initialize a CWS dataset from recorded snapshot files.","title":"__init__()"},{"location":"api/#parameters","text":"snapshot_filepaths : list-like of str, path or file-like objects, optional List of paths to the input snapshot recording files, passed to geopandas.read_file . snapshot_data_dir : str or pathlib.Path object Path to the directory where the snapshot recording files are located. Ignored if snapshot_filepaths is provided. snapshot_file_ext : str, optional File extension of the snapshot recording, used to obtain the list of input files in snapshot_data_dir . If None, the default value from settings.DEFAULT_SNAPSHOT_FILE_EXT is used. Ignored if snapshot_filepaths is provided. datetime_format : str, optional Datetime format string. Used to name the geo-data frame columns and the snapshot file dumps. If None, the default value from settings.DEFAULT_DATETIME_FORMAT is used. Source code in netatmo_geopy/core.py def __init__ ( self , * , snapshot_filepaths = None , snapshot_data_dir = None , snapshot_file_ext = None , datetime_format = None , ): \"\"\" Initialize a CWS dataset from recorded snapshot files. Parameters ---------- snapshot_filepaths : list-like of str, path or file-like objects, optional List of paths to the input snapshot recording files, passed to `geopandas.read_file`. snapshot_data_dir : str or pathlib.Path object Path to the directory where the snapshot recording files are located. Ignored if `snapshot_filepaths` is provided. snapshot_file_ext : str, optional File extension of the snapshot recording, used to obtain the list of input files in `snapshot_data_dir`. If None, the default value from `settings.DEFAULT_SNAPSHOT_FILE_EXT` is used. Ignored if `snapshot_filepaths` is provided. datetime_format : str, optional Datetime format string. Used to name the geo-data frame columns and the snapshot file dumps. If None, the default value from `settings.DEFAULT_DATETIME_FORMAT` is used. \"\"\" super ( CWSDataset , self ) . __init__ () if snapshot_filepaths is None : if snapshot_file_ext is None : snapshot_file_ext = settings . DEFAULT_SNAPSHOT_FILE_EXT snapshot_filepaths = glob . glob ( path . join ( snapshot_data_dir , f \"*. { snapshot_file_ext } \" ) ) self . snapshot_filepaths = snapshot_filepaths if datetime_format is None : datetime_format = settings . DEFAULT_DATETIME_FORMAT self . datetime_format = datetime_format","title":"Parameters"},{"location":"api/#netatmo_geopy.core.CWSRecorder","text":"CWSRecorder.","title":"CWSRecorder"},{"location":"api/#netatmo_geopy.core.CWSRecorder.__init__","text":"Initialize a CWS recorder for a given region.","title":"__init__()"},{"location":"api/#parameters","text":"lon_sw, lat_sw, lon_ne, lat_ne : numeric Latitude/longitude coordinates of the bounds of the region of interest dst_dir : str or pathlib.Path object, optional Path to the directory where the recorded snapshots are to be dumped. Only used when the dump_snapshot_gdf method is called, ignored otherwise. If None, the default value from settings.DEAFULT_DST_DIR . client_id, client_secret, username, password : str, optional Authentication credentials for Netatmo. If None, the respective values set in the \"NETATMO_CLIENT_ID\", \"NETATMO_CLIENT_SECRET\", \"NETATMO_USERNAME\" and \"NETATMO_PASSWORD\" environment variables are used. time_unit : str {\"second\", \"seconds\", \"minute\", \"minutes\", \"hour\", \"hours\", \"day\", \"days\", \"week\", \"weeks\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"}, optional Time unit. If None, no snaphots are taken periodically - snapshots are only taken by manually calling get_snapshot_gdf or dump_snapshot_gdf . interval : int, optional Quantity of the time unit set in time_unit , altogether defining the interval between snapshots. If None, the default value from the schedule library, i.e., 1, is used. Ignored if time_unit is None. at : str, optional Time string defining the particular time when snapshots are taken. See also https://schedule.readthedocs.io/en/stable/reference.html#schedule.Job.at. Ignored if time_unit is None. The following formats are accepted: * for daily jobs -> HH:MM:SS or HH:MM * for hourly jobs -> MM:SS or :MM * for minute jobs -> :SS. until : datetime.datetime, datetime.timedelta, datetime.time or str, optional Latest time (in the future) when a snapshot will be taken. If None, the periodic snapshots are taken indefinetly. Ignored if time_unit is None. The following formats are accepted: * datetime.datetime * datetime.timedelta * datetime.time * string in one of the following formats: \"%Y-%m-%d %H:%M:%S\", \"%Y-%m-%d %H:%M\", \"%Y-%m-%d\", \"%H:%M:%S\", \"%H:%M\" as defined by `datetime.strptime` behaviour. datetime_format : str, optional Datetime format string. Used to name the geo-data frame columns and the snapshot file dumps. If None, the default value from settings.DEFAULT_DATETIME_FORMAT is used. snapshot_file_ext : str, optional File extension used when dumping recorded snapshot files, which must match an OGR vector format driver (see fiona.supported_drivers ). If None, the default value from settings.DEFAULT_SNAPSHOT_FILE_EXT is used. save_responses : bool, optional Whether the JSON responses from the Netatmo public data API calls are stored. If None, the default value from settings.DEFAULT_SAVE_RESPONSES is used. save_responses_dir : str or pathlib.Path object, optional. Path to the directory where the JSON responses are to be stored. If None, the default value from settings.DEFAULT_SAVE_RESPONSES_DIR is used. Ignored if save_responses is False. Source code in netatmo_geopy/core.py def __init__ ( self , lon_sw , lat_sw , lon_ne , lat_ne , * , dst_dir = None , client_id = None , client_secret = None , username = None , password = None , time_unit = None , interval = None , at = None , until = None , datetime_format = None , snapshot_file_ext = None , save_responses = None , save_responses_dir = None , ): \"\"\" Initialize a CWS recorder for a given region. Parameters ---------- lon_sw, lat_sw, lon_ne, lat_ne : numeric Latitude/longitude coordinates of the bounds of the region of interest dst_dir : str or pathlib.Path object, optional Path to the directory where the recorded snapshots are to be dumped. Only used when the `dump_snapshot_gdf` method is called, ignored otherwise. If None, the default value from `settings.DEAFULT_DST_DIR`. client_id, client_secret, username, password : str, optional Authentication credentials for Netatmo. If None, the respective values set in the \"NETATMO_CLIENT_ID\", \"NETATMO_CLIENT_SECRET\", \"NETATMO_USERNAME\" and \"NETATMO_PASSWORD\" environment variables are used. time_unit : str {\"second\", \"seconds\", \"minute\", \"minutes\", \"hour\", \"hours\", \\ \"day\", \"days\", \"week\", \"weeks\", \"monday\", \"tuesday\", \"wednesday\", \\ \"thursday\", \"friday\", \"saturday\", \"sunday\"}, optional Time unit. If None, no snaphots are taken periodically - snapshots are only taken by manually calling `get_snapshot_gdf` or `dump_snapshot_gdf`. interval : int, optional Quantity of the time unit set in `time_unit`, altogether defining the interval between snapshots. If None, the default value from the `schedule` library, i.e., 1, is used. Ignored if `time_unit` is None. at : str, optional Time string defining the particular time when snapshots are taken. See also https://schedule.readthedocs.io/en/stable/reference.html#schedule.Job.at. Ignored if `time_unit` is None. The following formats are accepted: * for daily jobs -> HH:MM:SS or HH:MM * for hourly jobs -> MM:SS or :MM * for minute jobs -> :SS. until : datetime.datetime, datetime.timedelta, datetime.time or str, optional Latest time (in the future) when a snapshot will be taken. If None, the periodic snapshots are taken indefinetly. Ignored if `time_unit` is None. The following formats are accepted: * datetime.datetime * datetime.timedelta * datetime.time * string in one of the following formats: \"%Y-%m-%d %H:%M:%S\", \"%Y-%m-%d %H:%M\", \"%Y-%m-%d\", \"%H:%M:%S\", \"%H:%M\" as defined by `datetime.strptime` behaviour. datetime_format : str, optional Datetime format string. Used to name the geo-data frame columns and the snapshot file dumps. If None, the default value from `settings.DEFAULT_DATETIME_FORMAT` is used. snapshot_file_ext : str, optional File extension used when dumping recorded snapshot files, which must match an OGR vector format driver (see `fiona.supported_drivers`). If None, the default value from `settings.DEFAULT_SNAPSHOT_FILE_EXT` is used. save_responses : bool, optional Whether the JSON responses from the Netatmo public data API calls are stored. If None, the default value from `settings.DEFAULT_SAVE_RESPONSES`is used. save_responses_dir : str or pathlib.Path object, optional. Path to the directory where the JSON responses are to be stored. If None, the default value from `settings.DEFAULT_SAVE_RESPONSES_DIR`is used. Ignored if `save_responses` is False. \"\"\" super ( CWSRecorder , self ) . __init__ () self . lon_sw = lon_sw self . lat_sw = lat_sw self . lon_ne = lon_ne self . lat_ne = lat_ne self . dst_dir = dst_dir # auth self . _client_id = client_id self . _client_secret = client_secret self . _username = username self . _password = password # IO if datetime_format is None : datetime_format = settings . DEFAULT_DATETIME_FORMAT self . datetime_format = datetime_format if snapshot_file_ext is None : snapshot_file_ext = settings . DEFAULT_SNAPSHOT_FILE_EXT self . snapshot_file_ext = snapshot_file_ext if save_responses is None : save_responses = settings . DEFAULT_SAVE_RESPONSES self . save_responses = save_responses if save_responses_dir is None : save_responses_dir = settings . DEFAULT_SAVE_RESPONSES_DIR self . save_responses_dir = save_responses_dir # schedule if time_unit : if interval : caller = schedule . every ( interval ) else : caller = schedule . every () caller = getattr ( caller , time_unit ) if at : caller = caller . at ( at ) if until : caller = caller . until ( until ) caller . do ( self . dump_snapshot_gdf ) while schedule . get_jobs (): schedule . run_pending () time . sleep ( 1 )","title":"Parameters"},{"location":"api/#netatmo_geopy.core.CWSRecorder.dump_snapshot_gdf","text":"Get current CWS temperature snapshot and dump it to a file. Source code in netatmo_geopy/core.py def dump_snapshot_gdf ( self ): \"\"\"Get current CWS temperature snapshot and dump it to a file.\"\"\" snapshot_gdf = self . get_snapshot_gdf () dst_filepath = path . join ( self . dst_dir , f \" { _get_basename ( snapshot_gdf ) } . { self . snapshot_file_ext } \" ) snapshot_gdf . to_file ( dst_filepath ) utils . log ( f \"Dumped snapshot geo-data frame to file ' { dst_filepath } '\" )","title":"dump_snapshot_gdf()"},{"location":"api/#netatmo_geopy.core.CWSRecorder.get_snapshot_gdf","text":"Get current CWS temperature snapshot. Source code in netatmo_geopy/core.py def get_snapshot_gdf ( self ): \"\"\"Get current CWS temperature snapshot.\"\"\" response_json = _get_public_data ( self . lon_sw , self . lat_sw , self . lon_ne , self . lat_ne , client_id = self . _client_id , client_secret = self . _client_secret , username = self . _username , password = self . _password , ) snapshot_gdf = _gdf_from_response_json ( response_json , self . datetime_format ) if self . save_responses : dst_response_filepath = path . join ( self . save_responses_dir , f \" { _get_basename ( snapshot_gdf ) } .json\" ) with open ( dst_response_filepath , \"w\" ) as dst : json . dump ( response_json , dst ) utils . log ( f \"Dumped response to file ' { dst_response_filepath } '\" ) return snapshot_gdf","title":"get_snapshot_gdf()"},{"location":"api/#netatmo_geopy.core.plot_snapshot","text":"Plot a snapshot of station measurements.","title":"plot_snapshot()"},{"location":"api/#parameters","text":"snapshot_gdf : geopandas.GeoDataFrame Geo-data frame of CWS temperature measurements. snapshot_column : str, optional Column of CWS temperature measurements to plot. If None, the first column (other than geometry ) is used. ax : matplotlib.axes.Axes instancd, optional Plot in given axis. If None creates a new figure. cmap : str or matplotlib.colors.Colormap instance, optional Colormap of the plot. If None, the default value from settings.DEFAULT_PLOT_CMAP is used. legend : bool, optional Whether a legend should be added to the plot. If None, the default value from settings.DEFAULT_PLOT_LEGEND is used. legend_position : str {\"left\", \"right\", \"bottom\", \"top\"}, optional Position of the legend axes, passed to mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes . If None, the default value from settings.DEFAULT_PLOT_LEGEND_POSITION is used. legend_size : numeric or str, optional Size of the legend axes, passed to mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes . If None, the default value from settings.DEFAULT_PLOT_LEGEND_SIZE is used. legend_pad : numeric or str, optional Padding between the plot and legend axes, passed to mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes . If None, the default value from settings.DEFAULT_PLOT_LEGEND_PAD is used. title : bool or str, optional Whether a title should be added to the plot. If True, the timestamp of the snapshot (geo-data frame column) is used. It is also possible to pass a string so that it is used as title label (instead of the timestamp). If None, the default value from settings.DEFAULT_PLOT_TITLE is used. add_basemap : bool, optional Whether a basemap should be added to the plot using contextily.add_basemap . If None, the default value from settings.DEFAULT_PLOT_ADD_BASEMAP is used. attribution : str or bool, optional Attribution text for the basemap source, added to the bottom of the plot, passed to contextily.add_basemap . If False, no attribution is added. If None, the default value from settings.DEFAULT_PLOT_ATTRIBUTION is used. subplot_kws, plot_kws, set_title_kws, add_basemap_kws, append_axes_kws : dict, optional Keyword arguments passed to matplotlib.pyplot.subplots , geopandas.GeoDataFrame.plot , matplotlib.axes.Axes.set_title , contextily.add_basemap and mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes respectively.","title":"Parameters"},{"location":"api/#returns","text":"ax : matplotlib.axes.Axes Axes with the plot drawn onto it. Source code in netatmo_geopy/core.py def plot_snapshot ( # noqa: C901 snapshot_gdf , * , snapshot_column = None , ax = None , cmap = None , legend = None , legend_position = None , legend_size = None , legend_pad = None , title = None , add_basemap = None , attribution = None , subplot_kws = None , plot_kws = None , set_title_kws = None , add_basemap_kws = None , append_axes_kws = None , ): \"\"\" Plot a snapshot of station measurements. Parameters ---------- snapshot_gdf : geopandas.GeoDataFrame Geo-data frame of CWS temperature measurements. snapshot_column : str, optional Column of CWS temperature measurements to plot. If None, the first column (other than `geometry`) is used. ax : `matplotlib.axes.Axes` instancd, optional Plot in given axis. If None creates a new figure. cmap : str or `matplotlib.colors.Colormap` instance, optional Colormap of the plot. If None, the default value from `settings.DEFAULT_PLOT_CMAP` is used. legend : bool, optional Whether a legend should be added to the plot. If None, the default value from `settings.DEFAULT_PLOT_LEGEND` is used. legend_position : str {\"left\", \"right\", \"bottom\", \"top\"}, optional Position of the legend axes, passed to `mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes`. If None, the default value from `settings.DEFAULT_PLOT_LEGEND_POSITION` is used. legend_size : numeric or str, optional Size of the legend axes, passed to `mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes`. If None, the default value from `settings.DEFAULT_PLOT_LEGEND_SIZE` is used. legend_pad : numeric or str, optional Padding between the plot and legend axes, passed to `mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes`. If None, the default value from `settings.DEFAULT_PLOT_LEGEND_PAD` is used. title : bool or str, optional Whether a title should be added to the plot. If True, the timestamp of the snapshot (geo-data frame column) is used. It is also possible to pass a string so that it is used as title label (instead of the timestamp). If None, the default value from `settings.DEFAULT_PLOT_TITLE` is used. add_basemap : bool, optional Whether a basemap should be added to the plot using `contextily.add_basemap`. If None, the default value from `settings.DEFAULT_PLOT_ADD_BASEMAP` is used. attribution : str or bool, optional Attribution text for the basemap source, added to the bottom of the plot, passed to `contextily.add_basemap`. If False, no attribution is added. If None, the default value from `settings.DEFAULT_PLOT_ATTRIBUTION` is used. subplot_kws, plot_kws, set_title_kws, add_basemap_kws, append_axes_kws : dict, \\ optional Keyword arguments passed to `matplotlib.pyplot.subplots`, `geopandas.GeoDataFrame.plot`, `matplotlib.axes.Axes.set_title`, `contextily.add_basemap` and `mpl_toolkits.axes_grid1.axes_divider.AxesDivider.append_axes` respectively. Returns ------- ax : `matplotlib.axes.Axes` Axes with the plot drawn onto it. \"\"\" # if no column is provided, we plot the \"first\" column other than \"geometry\" if snapshot_column is None : snapshot_column = snapshot_gdf . columns . drop ( \"geometry\" )[ 0 ] # subplots arguments if ax is None : if subplot_kws is None : subplot_kws = {} fig , ax = plt . subplots ( ** subplot_kws ) # plot arguments if plot_kws is None : _plot_kws = {} else : _plot_kws = plot_kws . copy () # _plot_kws = {key: plot_kws[key] for key in plot_kws} if cmap is None : cmap = _plot_kws . pop ( \"cmap\" , settings . DEFAULT_PLOT_CMAP ) if legend is None : legend = _plot_kws . pop ( \"legend\" , settings . DEFAULT_PLOT_LEGEND ) # plot if legend : divider = make_axes_locatable ( ax ) if legend_position is None : legend_position = settings . DEFAULT_PLOT_LEGEND_POSITION if legend_size is None : legend_size = settings . DEFAULT_PLOT_LEGEND_SIZE if append_axes_kws is None : _append_axes_kws = {} else : _append_axes_kws = append_axes_kws . copy () if legend_pad is None : legend_pad = _append_axes_kws . pop ( \"pad\" , settings . DEFAULT_PLOT_LEGEND_PAD ) _plot_kws [ \"cax\" ] = divider . append_axes ( legend_position , legend_size , pad = legend_pad , ** _append_axes_kws ) snapshot_gdf . plot ( column = snapshot_column , cmap = cmap , ax = ax , legend = legend , ** _plot_kws ) if title is None : title = settings . DEFAULT_PLOT_TITLE if title : if title is True : title_label = snapshot_column elif isinstance ( title , str ): title_label = title if set_title_kws is None : set_title_kws = {} ax . set_title ( title_label , ** set_title_kws ) # basemap if add_basemap is None : add_basemap = settings . DEFAULT_PLOT_ADD_BASEMAP if add_basemap : # raise ImportError( # \"The contextily package is required for adding basemaps. \" # \"You can install it using 'conda install -c conda-forge contextily' or \" # \"'pip install contextily'.\" # ) # add_basemap arguments if add_basemap_kws is None : _add_basemap_kws = {} else : _add_basemap_kws = add_basemap_kws . copy () # _add_basemap_kws = {key: add_basemap_kws[key] for key in add_basemap_kws} if attribution is None : attribution = _add_basemap_kws . pop ( \"attribution\" , settings . DEFAULT_PLOT_ATTRIBUTION ) # add basemap cx . add_basemap ( ax = ax , crs = snapshot_gdf . crs , attribution = attribution , ** _add_basemap_kws , ) return ax","title":"Returns"},{"location":"api/#netatmo_geopy.settings","text":"Settings.","title":"settings"},{"location":"api/#netatmo_geopy.utils","text":"Utils (mostly from osmnx.utils ).","title":"utils"},{"location":"api/#netatmo_geopy.utils.log","text":"Write a message to the logger. This logs to file and/or prints to the console (terminal), depending on the current configuration of settings.LOG_FILE and settings.LOG_CONSOLE .","title":"log()"},{"location":"api/#parameters","text":"message : str The message to log. level : int One of Python's logger.level constants. name : str Name of the logger. filename : str Name of the log file, without file extension. Source code in netatmo_geopy/utils.py def log ( message , level = None , name = None , filename = None ): \"\"\" Write a message to the logger. This logs to file and/or prints to the console (terminal), depending on the current configuration of `settings.LOG_FILE` and `settings.LOG_CONSOLE`. Parameters ---------- message : str The message to log. level : int One of Python's logger.level constants. name : str Name of the logger. filename : str Name of the log file, without file extension. \"\"\" if level is None : level = settings . LOG_LEVEL if name is None : name = settings . LOG_NAME if filename is None : filename = settings . LOG_FILENAME # if logging to file is turned on if settings . LOG_FILE : # get the current logger (or create a new one, if none), then log # message at requested level logger = _get_logger ( level = level , name = name , filename = filename ) if level == lg . DEBUG : logger . debug ( message ) elif level == lg . INFO : logger . info ( message ) elif level == lg . WARNING : logger . warning ( message ) elif level == lg . ERROR : logger . error ( message ) # if logging to console (terminal window) is turned on if settings . LOG_CONSOLE : # prepend timestamp message = f \" { ts () } { message } \" # convert to ascii so it doesn't break windows terminals message = ( unicodedata . normalize ( \"NFKD\" , str ( message )) . encode ( \"ascii\" , errors = \"replace\" ) . decode () ) # print explicitly to terminal in case jupyter notebook is the stdout if getattr ( sys . stdout , \"_original_stdstream_copy\" , None ) is not None : # redirect captured pipe back to original os . dup2 ( sys . stdout . _original_stdstream_copy , sys . __stdout__ . fileno ()) sys . stdout . _original_stdstream_copy = None with redirect_stdout ( sys . __stdout__ ): print ( message , file = sys . __stdout__ , flush = True )","title":"Parameters"},{"location":"api/#netatmo_geopy.utils.ts","text":"Get current timestamp as str.","title":"ts()"},{"location":"api/#parameters","text":"style : str {\"datetime\", \"date\", \"time\"} Format the timestamp with this built-in template. template : str If not None, format the timestamp with this template instead of one of the built-in styles.","title":"Parameters"},{"location":"api/#returns","text":"ts : str The string timestamp. Source code in netatmo_geopy/utils.py def ts ( style = \"datetime\" , template = None ): \"\"\" Get current timestamp as str. Parameters ---------- style : str {\"datetime\", \"date\", \"time\"} Format the timestamp with this built-in template. template : str If not None, format the timestamp with this template instead of one of the built-in styles. Returns ------- ts : str The string timestamp. \"\"\" if template is None : if style == \"datetime\" : template = \"{:%Y-%m- %d %H:%M:%S}\" elif style == \"date\" : template = \"{:%Y-%m- %d }\" elif style == \"time\" : template = \"{:%H:%M:%S}\" else : # pragma: no cover raise ValueError ( f 'unrecognized timestamp style \" { style } \"' ) ts = template . format ( dt . datetime . now ()) return ts","title":"Returns"},{"location":"authors/","text":"Credits Development Lead Mart\u00ed Bosch marti.bosch@epfl.ch Contributors None yet. Why not be the first?","title":"Authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Mart\u00ed Bosch marti.bosch@epfl.ch","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/martibosch/netatmo_geopy/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation Netatmo GeoPy could always use more documentation, whether as part of the official Netatmo GeoPy docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback The best way to send feedback is to file an issue at https://github.com/martibosch/netatmo_geopy/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up netatmo_geopy for local development. Fork the netatmo_geopy repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/netatmo_geopy.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/martibosch/netatmo_geopy/actions and make sure that the tests pass for all supported Python versions. Tips``` $ pytest tests.test_netatmo_geopy ```To run a subset of tests. Deploying A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/martibosch/netatmo_geopy/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"Netatmo GeoPy could always use more documentation, whether as part of the official Netatmo GeoPy docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/martibosch/netatmo_geopy/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up netatmo_geopy for local development. Fork the netatmo_geopy repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/netatmo_geopy.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/martibosch/netatmo_geopy/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"$ pytest tests.test_netatmo_geopy ```To run a subset of tests.","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Travis will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history/","text":"History 0.1.0 (2022-02-14) First release on PyPI.","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2022-02-14","text":"First release on PyPI.","title":"0.1.0 (2022-02-14)"},{"location":"installation/","text":"Installation Stable release To install Netatmo GeoPy, run this command in your terminal: $ pip install netatmo_geopy This is the preferred method to install Netatmo GeoPy, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source The source for Netatmo GeoPy can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/martibosch/netatmo_geopy Or download the tarball : $ curl -OJL https://github.com/martibosch/netatmo_geopy/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install Netatmo GeoPy, run this command in your terminal: $ pip install netatmo_geopy This is the preferred method to install Netatmo GeoPy, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for Netatmo GeoPy can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/martibosch/netatmo_geopy Or download the tarball : $ curl -OJL https://github.com/martibosch/netatmo_geopy/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"usage/","text":"Usage Pre-requisites In order to access the data from Netatmo citizen weather stations (CWS), you need a Netatmo username, password, client ID and client secret. You can obtain the former credentials following the steps below: Create an Netatmo account at auth.netatmo.com/access/signup . The entered email address and password will respectively be the username and password used in netatmo-geopy. From your account, navigate to dev.netatmo.com/apps/ and click \"Create\" to create an app. This only serves to obtain a client ID and secret key, so you do not need to enter any specific information in \"app name\" and \"description\". Once the app is created, save the generated \"client ID\" and \"client secret\" which will appear in the form below (entitled \"App Technical Parameters\"), which will be used in netatmo-geopy. Features First import netatmo-geopy as in: import netatmo_geopy as nat You can then use netatmo-geopy to get the CWS temperature measurements for a region of interest as in: # latitude/longitude bounds of the region of interest lon_sw, lat_sw, lon_ne, lat_ne = 6.5175, 46.5012, 6.7870, 46.6058 # init the CWS recorder cws_recorder = nat.CWSRecorder( lon_sw, lat_sw, lon_ne, lat_ne, username=\"<your-netatmo-username>\", password=\"<your-netatmo-password>\", client_id=\"<your-netatmo-client-id>\", client_secret=\"<your-netatmo-client-secret>\", ) Alternatively, instead of passing the Netatmo credentials to the initalization of CWSRecorder , you can also set them as the NETATMO_USERNAME , NETATMO_PASSWORD , NETATMO_CLIENT_ID , and NETATMO_CLIENT_SECRET environment variables, then netatmo-geopy will use them automatically when required. In order to use more concise code snippets, the remainder of this page assumes that the Netatmo credientials are provided using the environment variables. Then, the current snapshot of CWS measurements in the region can be obtained as in: gdf = cws_recorder.get_snapshot_gdf() gdf.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2022-02-12T19:13 geometry station_id 02:00:00:01:5e:e0 6.6 POINT (6.82799 46.47089) 02:00:00:22:c0:c0 4.9 POINT (6.82904 46.47005) 02:00:00:2f:0b:16 3.5 POINT (6.82516 46.47294) 02:00:00:59:00:2a 3.8 POINT (6.84547 46.46779) 02:00:00:52:ed:5a 3.8 POINT (6.87359 46.47067) You can also use the plot_snapshot to plot the data on a map: nat.plot_snapshot(gdf) Schedule a periodic job to record CWS data for a region It is possible to use netatmo-geopy to set up a periodic job to record CWS measurements. To that end, you need to provide the time_unit argument to the initialization of CWSRecorder , as in: snapshot_data_dir = \"data/lausanne\" cws_recorder = nat.CWSRecorder( lon_sw, lat_sw, lon_ne, lat_ne, dst_dir=snapshot_data_dir, time_unit=\"hour\" ) which will dump an hourly snapshot of CWS measurements to the directory specified with the dst_dir argument. The time_unit argument can be combined with the interval , at and until arguments, e.g., the following task will record the CWS measurements of the region at the 30th minute of every three hours for the next 24 hours: from datetime import datetime, timedelta cws_recorder = nat.CWSRecorder( lon_sw, lat_sw, lon_ne, lat_ne, dst_dir=snapshot_data_dir, time_unit=\"hours\", interval=3 at=\":30\", until=datetime.now() + timedelta(hours=24), ) See the documentation of schedule for more examples on scheduling periodic jobs. Assemble CWS snapshots into a single time-series geo-data frame After a time series of snapshots have been dumped to a directory, the CWSDataset class can be used to assemble the data into a single geo-data frame, i.e., the temperature_gdf attribute: cws_dataset = nat.CWSDataset(snapshot_data_dir=snapshot_data_dir) cws_dataset.temperature_gdf.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2022-02-06 09:30:00 2022-02-06 12:30:00 2022-02-06 15:30:00 2022-02-06 18:30:00 2022-02-06 21:30:00 2022-02-07 00:30:00 2022-02-07 03:30:00 2022-02-07 06:30:00 geometry station_id 02:00:00:01:5e:e0 1.542567 4.815597 0.550991 0.948516 2.600634 0.312831 3.088689 3.442664 POINT (6.82799 46.47089) 02:00:00:22:c0:c0 4.093453 2.291656 0.258319 3.346670 4.571841 2.299931 0.447544 4.558038 POINT (6.82904 46.47005) 02:00:00:2f:0b:16 1.588176 4.521104 3.060942 1.931824 3.027879 2.567090 1.326534 0.043705 POINT (6.82516 46.47294) 02:00:00:59:00:2a 0.452659 2.443335 2.270666 0.867035 3.965786 2.200247 3.443507 1.314949 POINT (6.84547 46.46779) 02:00:00:52:ed:5a 1.022992 1.795367 1.099024 2.775641 1.663362 1.033040 1.875658 1.031009 POINT (6.87359 46.47067)","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#pre-requisites","text":"In order to access the data from Netatmo citizen weather stations (CWS), you need a Netatmo username, password, client ID and client secret. You can obtain the former credentials following the steps below: Create an Netatmo account at auth.netatmo.com/access/signup . The entered email address and password will respectively be the username and password used in netatmo-geopy. From your account, navigate to dev.netatmo.com/apps/ and click \"Create\" to create an app. This only serves to obtain a client ID and secret key, so you do not need to enter any specific information in \"app name\" and \"description\". Once the app is created, save the generated \"client ID\" and \"client secret\" which will appear in the form below (entitled \"App Technical Parameters\"), which will be used in netatmo-geopy.","title":"Pre-requisites"},{"location":"usage/#features","text":"First import netatmo-geopy as in: import netatmo_geopy as nat You can then use netatmo-geopy to get the CWS temperature measurements for a region of interest as in: # latitude/longitude bounds of the region of interest lon_sw, lat_sw, lon_ne, lat_ne = 6.5175, 46.5012, 6.7870, 46.6058 # init the CWS recorder cws_recorder = nat.CWSRecorder( lon_sw, lat_sw, lon_ne, lat_ne, username=\"<your-netatmo-username>\", password=\"<your-netatmo-password>\", client_id=\"<your-netatmo-client-id>\", client_secret=\"<your-netatmo-client-secret>\", ) Alternatively, instead of passing the Netatmo credentials to the initalization of CWSRecorder , you can also set them as the NETATMO_USERNAME , NETATMO_PASSWORD , NETATMO_CLIENT_ID , and NETATMO_CLIENT_SECRET environment variables, then netatmo-geopy will use them automatically when required. In order to use more concise code snippets, the remainder of this page assumes that the Netatmo credientials are provided using the environment variables. Then, the current snapshot of CWS measurements in the region can be obtained as in: gdf = cws_recorder.get_snapshot_gdf() gdf.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2022-02-12T19:13 geometry station_id 02:00:00:01:5e:e0 6.6 POINT (6.82799 46.47089) 02:00:00:22:c0:c0 4.9 POINT (6.82904 46.47005) 02:00:00:2f:0b:16 3.5 POINT (6.82516 46.47294) 02:00:00:59:00:2a 3.8 POINT (6.84547 46.46779) 02:00:00:52:ed:5a 3.8 POINT (6.87359 46.47067) You can also use the plot_snapshot to plot the data on a map: nat.plot_snapshot(gdf)","title":"Features"},{"location":"usage/#schedule-a-periodic-job-to-record-cws-data-for-a-region","text":"It is possible to use netatmo-geopy to set up a periodic job to record CWS measurements. To that end, you need to provide the time_unit argument to the initialization of CWSRecorder , as in: snapshot_data_dir = \"data/lausanne\" cws_recorder = nat.CWSRecorder( lon_sw, lat_sw, lon_ne, lat_ne, dst_dir=snapshot_data_dir, time_unit=\"hour\" ) which will dump an hourly snapshot of CWS measurements to the directory specified with the dst_dir argument. The time_unit argument can be combined with the interval , at and until arguments, e.g., the following task will record the CWS measurements of the region at the 30th minute of every three hours for the next 24 hours: from datetime import datetime, timedelta cws_recorder = nat.CWSRecorder( lon_sw, lat_sw, lon_ne, lat_ne, dst_dir=snapshot_data_dir, time_unit=\"hours\", interval=3 at=\":30\", until=datetime.now() + timedelta(hours=24), ) See the documentation of schedule for more examples on scheduling periodic jobs.","title":"Schedule a periodic job to record CWS data for a region"},{"location":"usage/#assemble-cws-snapshots-into-a-single-time-series-geo-data-frame","text":"After a time series of snapshots have been dumped to a directory, the CWSDataset class can be used to assemble the data into a single geo-data frame, i.e., the temperature_gdf attribute: cws_dataset = nat.CWSDataset(snapshot_data_dir=snapshot_data_dir) cws_dataset.temperature_gdf.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2022-02-06 09:30:00 2022-02-06 12:30:00 2022-02-06 15:30:00 2022-02-06 18:30:00 2022-02-06 21:30:00 2022-02-07 00:30:00 2022-02-07 03:30:00 2022-02-07 06:30:00 geometry station_id 02:00:00:01:5e:e0 1.542567 4.815597 0.550991 0.948516 2.600634 0.312831 3.088689 3.442664 POINT (6.82799 46.47089) 02:00:00:22:c0:c0 4.093453 2.291656 0.258319 3.346670 4.571841 2.299931 0.447544 4.558038 POINT (6.82904 46.47005) 02:00:00:2f:0b:16 1.588176 4.521104 3.060942 1.931824 3.027879 2.567090 1.326534 0.043705 POINT (6.82516 46.47294) 02:00:00:59:00:2a 0.452659 2.443335 2.270666 0.867035 3.965786 2.200247 3.443507 1.314949 POINT (6.84547 46.46779) 02:00:00:52:ed:5a 1.022992 1.795367 1.099024 2.775641 1.663362 1.033040 1.875658 1.031009 POINT (6.87359 46.47067)","title":"Assemble CWS snapshots into a single time-series geo-data frame"}]}